[{"/Users/richardjarram/code/catonmat/trumpsweeper/src/reportWebVitals.ts":"1","/Users/richardjarram/code/catonmat/trumpsweeper/src/App.tsx":"2","/Users/richardjarram/code/catonmat/trumpsweeper/src/index.tsx":"3","/Users/richardjarram/code/catonmat/trumpsweeper/src/components/Board.tsx":"4","/Users/richardjarram/code/catonmat/trumpsweeper/src/components/Toolbar.tsx":"5","/Users/richardjarram/code/catonmat/trumpsweeper/src/contexts.ts":"6","/Users/richardjarram/code/catonmat/trumpsweeper/src/components/Cell.tsx":"7","/Users/richardjarram/code/catonmat/trumpsweeper/src/globals.ts":"8","/Users/richardjarram/code/catonmat/trumpsweeper/src/components/TopPanel.tsx":"9","/Users/richardjarram/code/catonmat/trumpsweeper/src/components/ModalCompletion.tsx":"10"},{"size":425,"mtime":1607207666653,"results":"11","hashOfConfig":"12"},{"size":2496,"mtime":1611868872676,"results":"13","hashOfConfig":"12"},{"size":501,"mtime":1607208543401,"results":"14","hashOfConfig":"12"},{"size":9804,"mtime":1611626886910,"results":"15","hashOfConfig":"12"},{"size":2606,"mtime":1611199158687,"results":"16","hashOfConfig":"12"},{"size":2357,"mtime":1611868982476,"results":"17","hashOfConfig":"12"},{"size":2603,"mtime":1611626852175,"results":"18","hashOfConfig":"12"},{"size":9923,"mtime":1611459393797,"results":"19","hashOfConfig":"12"},{"size":1767,"mtime":1611625574025,"results":"20","hashOfConfig":"12"},{"size":947,"mtime":1611459412553,"results":"21","hashOfConfig":"12"},{"filePath":"22","messages":"23","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"24"},"1kvdwj7",{"filePath":"25","messages":"26","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"27","messages":"28","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"24"},{"filePath":"29","messages":"30","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"31","usedDeprecatedRules":"24"},{"filePath":"32","messages":"33","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"24"},{"filePath":"34","messages":"35","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"36","messages":"37","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"24"},{"filePath":"38","messages":"39","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"24"},{"filePath":"40","messages":"41","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"42","usedDeprecatedRules":"24"},{"filePath":"43","messages":"44","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"24"},"/Users/richardjarram/code/catonmat/trumpsweeper/src/reportWebVitals.ts",[],["45","46"],"/Users/richardjarram/code/catonmat/trumpsweeper/src/App.tsx",["47"],"/Users/richardjarram/code/catonmat/trumpsweeper/src/index.tsx",[],"/Users/richardjarram/code/catonmat/trumpsweeper/src/components/Board.tsx",["48","49","50"],"import _ from 'lodash'\nimport { useState, useEffect } from 'react'\nimport './Board.scss'\nimport Cell from './Cell'\nimport { useGameContext } from '../contexts'\nimport { \n  BoardState, \n  CellState,\n  setCellStyle,\n  GameProgress\n} \nfrom '../globals'\n\nconst Board: React.FC<BoardState> = ({boardSize, numberOfMines, mineMap} : BoardState ) => { \n  // TODO: Refactor this enum to remove redundant `state` key\n  const { difficulty, gameProgress, setGameProgress, flags, setFlags } = useGameContext()\n\n  const [ grid, setGrid ] = useState(buildBoard({boardSize, numberOfMines, mineMap}))\n  const [ correctlyFlaggedCells, setCorrectlyFlaggedCells ] = useState(0)\n\n  // Flag logic: accounts for when you switch difficulty; resets to zero\n  useEffect(() => {\n    setFlags(0)\n    setCorrectlyFlaggedCells(0) \n  }, [gameProgress, difficulty])\n\n  // redraw board after clicking on a cell\n  useEffect(() => {\n    setGrid(buildBoard({boardSize, numberOfMines, mineMap}))\n  }, [boardSize, numberOfMines, mineMap])\n\n  // redraw board after clicking on restart game modal\n  useEffect(() => {\n    if (gameProgress === GameProgress.BeginNewGame) { \n      setGrid(buildBoard({boardSize, numberOfMines, mineMap}))\n    }\n  }, [gameProgress])\n\n  // Completion: redraw board after victory\n  useEffect(() => {\n    if (correctlyFlaggedCells === numberOfMines) {\n      const updatedGrid: [any[], any[]] = _.cloneDeep(grid)\n\n      for (let row = 0; row < boardSize; row ++) {\n        for (let col = 0; col < boardSize; col ++) {\n          updatedGrid[row][col].clicked = true\n        }\n      }\n\n      setGrid(updatedGrid)\n      setGameProgress(GameProgress.Won)\n    }\n  })\n  \n  // TODO: rebuild this functionality with useContext and/or useRef()\n  // https://blog.logrocket.com/how-to-get-previous-props-state-with-react-hooks/\n  // assumption was to 'optimize' React.render by doing in-place modification of `grid` rather than re-drawing the \n  // entire board after each click. I guess I have to do the naive thing and re-render the board each time...\n  function updateBoard(j: number, i: number, rightClick?: boolean) {\n    const updatedGrid: [any[], any[]] = _.cloneDeep(grid)\n    const cell = updatedGrid[j][i]\n\n    if (rightClick) {\n      const validCell = cell.style.backgroundImage === 'url(/images/retro/unopened.svg)' ||\n      cell.style.backgroundImage === 'url(/images/retro/flag.svg)'\n      \n      if (cell.flagged === true && validCell) { \n        cell.flagged = false\n        if (flags > 0) {\n          setFlags(flags - 1)\n        }\n        if (cell.mine) {\n          setCorrectlyFlaggedCells(correctlyFlaggedCells - 1)\n        }\n      } else if (cell.flagged === false && validCell && flags < numberOfMines) { \n        cell.flagged = true\n        setFlags(flags + 1)\n        if (cell.mine) {\n          setCorrectlyFlaggedCells(correctlyFlaggedCells + 1)\n        }\n      }\n\n      // TODO: refactor this duplicate logic\n      if (correctlyFlaggedCells === numberOfMines) {\n        // set game state to won\n        // setGameProgress(GameProgress.Won)\n        // reveal entire board\n        for (let row = 0; row < boardSize; row ++) {\n          for (let col = 0; col < boardSize; col ++) {\n            updatedGrid[row][col].clicked = true\n          }\n        }\n      }\n      setGrid(updatedGrid)\n      return\n    }\n\n    // cell is a mine reveal entire board\n    if (cell.mine) { \n      for (let row = 0; row < boardSize; row ++) {\n        for (let col = 0; col < boardSize; col ++) {\n          updatedGrid[row][col].clicked = true\n        }\n      }\n\n      setGameProgress(GameProgress.Lost)\n      setGrid(updatedGrid)\n      return\n    }\n\n    // recursively open all blank cells\n    let stack: any = []\n    stack.push(cell)\n\n    while (stack.length > 0) {\n      const currentCell = stack.shift()\n\n      if (!currentCell.mine && !currentCell.clicked) {\n        currentCell.clicked = true\n        currentCell.style = setCellStyle(cell)\n      }\n\n      if (currentCell.neighbors === 0) {\n        const j = currentCell.location[0]\n        const i = currentCell.location[1]\n  \n        let neighborCell = updatedGrid[j-1] && updatedGrid[j-1][i-1] && !updatedGrid[j-1][i-1].mine && !updatedGrid[j-1][i-1].clicked //&& updatedGrid[j-1][i-1].neighbors === 0 // top left\n        if (neighborCell) stack.push(updatedGrid[j-1][i-1])\n        neighborCell = updatedGrid[j-1] && updatedGrid[j-1][i] && !updatedGrid[j-1][i].mine && !updatedGrid[j-1][i].clicked //&& updatedGrid[j-1][i].neighbors === 0 // top \n        if (neighborCell) stack.push(updatedGrid[j-1][i])\n        neighborCell = updatedGrid[j-1] && updatedGrid[j-1][i+1] && !updatedGrid[j-1][i+1].mine && !updatedGrid[j-1][i+1].clicked //&& updatedGrid[j-1][i+1].neighbors === 0 // top right\n        if (neighborCell) stack.push(updatedGrid[j-1][i+1])\n        neighborCell = updatedGrid[j] && updatedGrid[j][i-1] && !updatedGrid[j][i-1].mine && !updatedGrid[j][i-1].clicked //&& updatedGrid[j][i-1].neighbors === 0 // left\n        if (neighborCell) stack.push(updatedGrid[j][i-1])\n        neighborCell = updatedGrid[j] && updatedGrid[j][i+1] && !updatedGrid[j][i+1].mine && !updatedGrid[j][i+1].clicked //&& updatedGrid[j][i+1].neighbors === 0 //right\n        if (neighborCell) stack.push(updatedGrid[j][i+1])\n        neighborCell = updatedGrid[j+1] && updatedGrid[j+1][i-1] && !updatedGrid[j+1][i-1].mine && !updatedGrid[j+1][i-1].clicked //&& updatedGrid[j+1][i-1].neighbors === 0 //bottom right\n        if (neighborCell) stack.push(updatedGrid[j+1][i-1])\n        neighborCell = updatedGrid[j+1] && updatedGrid[j+1][i] && !updatedGrid[j+1][i].mine && !updatedGrid[j+1][i].clicked //&& updatedGrid[j+1][i].neighbors === 0 // bottom\n        if (neighborCell) stack.push(updatedGrid[j+1][i])\n        neighborCell = updatedGrid[j+1] && updatedGrid[j+1][i+1] && !updatedGrid[j+1][i+1].mine && !updatedGrid[j+1][i+1].clicked //&& updatedGrid[j+1][i+1].neighbors === 0 // bottom right\n        if (neighborCell) stack.push(updatedGrid[j+1][i+1])\n      }\n    }\n\n    setGameProgress(GameProgress.InProgress)\n    setGrid(updatedGrid)\n  }\n\n  return (\n    <div data-testid='board' className='board-container' id={difficulty}>\n      { \n        grid.map((column: any) => {\n          return (column.map((cellState: CellState, rowIndex: number) => { \n            // pass updateBoard() function to each child cell; on game boot up the grid is empty \n            // and so this function is nil, that is why we assign it here. \n            cellState.updateBoard = updateBoard\n            return (<Cell key={rowIndex} {...cellState}/>)\n          }))\n        })\n      }\n    </div>\n  )\n}\n\nfunction buildBoard(\n  {\n    boardSize, \n    numberOfMines,\n    mineMap\n  } : \n  { \n      boardSize: number, \n      numberOfMines: number, \n      mineMap: [number, number][]\n  }\n) \n{\n  // const userDesiresRandomMineGeneration = numberOfMines > 0\n  // const userDoesNotDesireRandomMineGeneration = mineMap[0][0] !== -1 || mineMap[0][1] !== -1 \n\n  // if (userDesiresRandomMineGeneration && userDoesNotDesireRandomMineGeneration) { \n  //   throw new Error('Please EITHER set Random Mines via `numberOfMines` or use a `mineMap` to manually build mines on the grid.')\n  // }\n  \n  // Build the empty grid\n  const grid: [any[], any[]] = [[],[]]\n  for (let j = 0; j < boardSize; j++) {\n    if (grid[j] === undefined) grid.push([])\n    for (let i = 0; i < boardSize; i++) {\n      if (grid[j][i] === undefined) grid[j].push([])\n    }\n  }\n\n  // randomly select cells from grid to turn into mines;\n  // will only run if no `mineMap` has been provided\n  const userDesiresRandomMineGeneration = (mineMap[0][0] === -1 && mineMap[0][1] === -1) || (mineMap === undefined)\n  if (userDesiresRandomMineGeneration) {\n    let mineCount: number = 0\n  \n    while (mineCount < numberOfMines) {\n      let randomRow = Math.ceil(Math.random() * (grid.length - 1))\n      let randomCol = Math.ceil(Math.random() * (grid[0].length - 1))\n      let cell = grid[randomRow][randomCol]\n  \n      if (!cell.includes('mine')) { \n        cell.push('mine')\n        mineCount += 1\n      }\n    }\n  }\n\n  // populate the grid with cells\n  for (let j = 0; j < boardSize; j++) {\n    for (let i = 0; i < boardSize; i++) {\n      // set mines according to user defined `MineMap`; used specifically in test case in Board.test.tsx OR set random mines\n      const mine = mineMap.find(cell => cell[0] === j && cell[1] === i) || grid[j][i][0] === 'mine'\n\n      const cellState: CellState = {\n        location: [j, i],\n        clicked: false,\n        mine: mine ? true : false,\n        flagged: false,\n        neighbors: 0\n      }\n\n      cellState.style = setCellStyle(cellState)\n      grid[j][i] = cellState\n    }\n  }\n\n  // build neighbors\n  for (let j = 0; j < boardSize; j++) {\n    for (let i = 0; i < boardSize; i ++) {\n      let neighbors = 0\n\n      const topLeft = grid[j-1] && grid[j-1][i-1] && grid[j-1][i-1].mine // top left\n      if (topLeft) neighbors += 1\n      const top = grid[j-1] && grid[j-1][i] && grid[j-1][i].mine // top \n      if (top) neighbors += 1\n      const topRight = grid[j-1] && grid[j-1][i+1] && grid[j-1][i+1].mine // top right\n      if (topRight) neighbors += 1\n      const left = grid[j] && grid[j][i-1] && grid[j][i-1].mine // left\n      if (left) neighbors += 1\n      const right = grid[j] && grid[j][i+1] && grid[j][i+1].mine //right\n      if (right) neighbors += 1\n      const bottomLeft = grid[j+1] && grid[j+1][i-1] && grid[j+1][i-1].mine //bottom right\n      if (bottomLeft) neighbors += 1\n      const bottom = grid[j+1] && grid[j+1][i] && grid[j+1][i].mine // bottom\n      if (bottom) neighbors += 1\n      const bottomRight = grid[j+1] && grid[j+1][i+1] && grid[j+1][i+1].mine // bottom right\n      if (bottomRight) neighbors += 1\n\n      grid[j][i].neighbors = neighbors\n    }\n  }\n\n  return grid\n}\n\nexport default Board\n","/Users/richardjarram/code/catonmat/trumpsweeper/src/components/Toolbar.tsx",[],"/Users/richardjarram/code/catonmat/trumpsweeper/src/contexts.ts",["51","52"],"/Users/richardjarram/code/catonmat/trumpsweeper/src/components/Cell.tsx",[],"/Users/richardjarram/code/catonmat/trumpsweeper/src/globals.ts",[],"/Users/richardjarram/code/catonmat/trumpsweeper/src/components/TopPanel.tsx",["53"],"import React, { useEffect } from 'react'\nimport { GameProgress } from '../globals'\nimport { useGameContext } from '../contexts'\nimport './TopPanel.scss'\n\nexport default function TopPanel() {\n  const { gameProgress } = useGameContext()\n  const [time, setTime] = React.useState(0)\n\n  // countdown timer logic\n  useEffect(() => {\n    if (gameProgress === GameProgress.NewGame || gameProgress === GameProgress.Lost) setTime(0) \n    if (gameProgress === GameProgress.InProgress) {\n      const interval = setInterval(() => setTime(time + 1), 1000)\n      return () => clearInterval(interval)\n    }\n  })\n  \n  return (\n    <>\n      <div data-testid='topPanel'>\n        <FlagCounter/>\n        <Avatar gameProgress={gameProgress}/>\n        <div>Timer: <span data-testid='timer'>{time}</span></div>\n      </div>\n    </>\n  )\n}\n\nfunction FlagCounter() {\n  const { flags, numberOfMines } = useGameContext()\n\n  return(\n    <>\n      { numberOfMines && <span data-testid=\"flag-counter\">{numberOfMines - flags}</span> }\n    </>\n  )\n}\n\nfunction Avatar({gameProgress} : { gameProgress: GameProgress}) {\n  let { rightClickHeldDown } = useGameContext()\n  let avatarUrl\n\n  // avatar changes if user holds down left mouse button\n  if (rightClickHeldDown) {\n    avatarUrl = \"/images/retro/avatar/wow.png\"\n  } else {\n    // avatar changes according to game state\n    switch(gameProgress) {\n      case GameProgress.Won:\n        avatarUrl = \"/images/retro/avatar/happy.png\"\n        break\n      case GameProgress.Lost:\n        avatarUrl = \"/images/retro/avatar/sad.png\"\n        break\n      default:\n        avatarUrl = \"/images/retro/avatar/angry.png\"\n        break\n    }\n  }\n\n  return(\n    <>\n      <p>Avatar</p>\n      <img data-testid=\"avatar\" id=\"avatar\" src={avatarUrl} alt=\"\"/>\n    </>\n  )\n}\n","/Users/richardjarram/code/catonmat/trumpsweeper/src/components/ModalCompletion.tsx",[],{"ruleId":"54","replacedBy":"55"},{"ruleId":"56","replacedBy":"57"},{"ruleId":"58","severity":1,"message":"59","line":8,"column":10,"nodeType":"60","messageId":"61","endLine":8,"endColumn":21},{"ruleId":"62","severity":1,"message":"63","line":25,"column":6,"nodeType":"64","endLine":25,"endColumn":32,"suggestions":"65"},{"ruleId":"62","severity":1,"message":"66","line":37,"column":6,"nodeType":"64","endLine":37,"endColumn":20,"suggestions":"67"},{"ruleId":"62","severity":1,"message":"68","line":40,"column":3,"nodeType":"60","endLine":40,"endColumn":12,"suggestions":"69"},{"ruleId":"58","severity":1,"message":"70","line":2,"column":8,"nodeType":"60","messageId":"61","endLine":2,"endColumn":13},{"ruleId":"58","severity":1,"message":"71","line":3,"column":67,"nodeType":"60","messageId":"61","endLine":3,"endColumn":76},{"ruleId":"62","severity":1,"message":"72","line":11,"column":3,"nodeType":"60","endLine":11,"endColumn":12,"suggestions":"73"},"no-native-reassign",["74"],"no-negated-in-lhs",["75"],"@typescript-eslint/no-unused-vars","'trumpTweets' is defined but never used.","Identifier","unusedVar","react-hooks/exhaustive-deps","React Hook useEffect has a missing dependency: 'setFlags'. Either include it or remove the dependency array.","ArrayExpression",["76"],"React Hook useEffect has missing dependencies: 'boardSize', 'mineMap', and 'numberOfMines'. Either include them or remove the dependency array. If 'setGrid' needs the current value of 'boardSize', you can also switch to useReducer instead of useState and read 'boardSize' in the reducer.",["77"],"React Hook useEffect contains a call to 'setGrid'. Without a list of dependencies, this can lead to an infinite chain of updates. To fix this, pass [correctlyFlaggedCells, numberOfMines, grid, setGameProgress, boardSize] as a second argument to the useEffect Hook.",["78"],"'Board' is defined but never used.","'CellState' is defined but never used.","React Hook useEffect contains a call to 'setTime'. Without a list of dependencies, this can lead to an infinite chain of updates. To fix this, pass [gameProgress, time] as a second argument to the useEffect Hook.",["79"],"no-global-assign","no-unsafe-negation",{"desc":"80","fix":"81"},{"desc":"82","fix":"83"},{"desc":"84","fix":"85"},{"desc":"86","fix":"87"},"Update the dependencies array to be: [gameProgress, difficulty, setFlags]",{"range":"88","text":"89"},"Update the dependencies array to be: [boardSize, gameProgress, mineMap, numberOfMines]",{"range":"90","text":"91"},"Add dependencies array: [correctlyFlaggedCells, numberOfMines, grid, setGameProgress, boardSize]",{"range":"92","text":"93"},"Add dependencies array: [gameProgress, time]",{"range":"94","text":"95"},[806,832],"[gameProgress, difficulty, setFlags]",[1206,1220],"[boardSize, gameProgress, mineMap, numberOfMines]",[1645,1645],", [correctlyFlaggedCells, numberOfMines, grid, setGameProgress, boardSize]",[594,594],", [gameProgress, time]"]